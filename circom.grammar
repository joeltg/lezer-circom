// Some general notes:

// The structure here is just split up into "statements" and "blocks",
// there's no awareness of which kinds of statements are valid in which
// contexts. Not allowing pragma inside templates or signals inside
// functions etc. is something we could add with a little more effort,
// but for now it's any statement anywhere.

// In circom, templates/components and variables/functions mirror each other,
// but we're not actually able to syntactically distinguish them in all cases.
// For example "foo[3] = bar()" might be assigning a component slot with a
// template call, or a variable slot with a function call. This means we can't
// do very much type-checking inside the parser: we just have one Assignment
// statement that takes a NumericExpression, and statements that are actually
// template calls assigned to components will parse as Assignment statements
// where the NumericExpression is a Call (used for both template and function calls).
// So it'll be on the linter to look out for other kinds of numeric expressions
// assigned to component variables (like "component foo; foo = 4 + 2;") which will
// parse successfully into (Assignment (Addition Number Number))

// (If we *really* wanted to distinguish them inside the parser I think it is
// actually possible to with a "context tracker" but I haven't used them before
// and it seems complicated https://lezer.codemirror.net/docs/ref/#lr.ContextTracker)

@tokens {
  Number { std.digit+ }
  CompilerVersion { Number "." Number "." Number }

  OpenBrace[closedBy="CloseBrace"] { "{" }
  CloseBrace[openedBy="OpenBrace"] { "}" }
  OpenBracket[closedBy="CloseBracket"] { "[" }
  CloseBracket[openedBy="OpenBracket"] { "]" }
  OpenParen[closedBy="CloseParen"] { "(" }
  CloseParen[openedBy="OpenParen"] { ")" }

  space { $[ \t\n]+ }
  LineComment { "//" ![\n]* }
  BlockComment { "/*" blockCommentRest }
  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  divide { "/" }
  divideAssign { "/=" }
  @precedence { BlockComment, LineComment, divideAssign, divide }

  Identifier { (std.asciiLetter | "_") (std.asciiLetter | std.digit | "$" | "_")* }

  // These are the JSON escaping rules, idk what the circom compiler expects
  char { $[\u{20}\u{21}\u{23}-\u{5b}\u{5d}-\u{10ffff}] | "\\" esc }
  esc  { $["\\\/bfnrt] | "u" hexDig hexDig hexDig hexDig }
  hexDig { $[0-9A-Fa-f] }
  String { '"' char* '"' }
}

@precedence {
  L1 @left,
  L2 @left,
  L3 @left,
  L4 @left,
  L5 @left,
  L6 @left,
  L7 @left,
  L8 @left,
  L9 @left
}

@skip { space | LineComment | BlockComment }

kw<word> { @specialize[@name={word}]<Identifier, word> }
list<item> { (item ("," item)*)? }

Array<item> { OpenBracket Items { list<item> } CloseBracket }
nestedArray<item> { item | Array<nestedArray<item>> }

ArraySize { OpenBracket topLevelNumericExpression CloseBracket }
ArrayIndex { OpenBracket topLevelNumericExpression CloseBracket }
ParameterList { OpenParen Parameters { list<Identifier> } CloseParen }
ParameterValueList { OpenParen ParameterValues { list<topLevelNumericExpression> } CloseParen }

// the docs say conditionals aren't allowed here
Log { kw<"log"> OpenParen (numericExpression | booleanExpression) CloseParen } 
Assert { kw<"assert"> OpenParen booleanExpression CloseParen }

body<statement, block> { (statement ";" | block)* }
@top Circuit { body<circuitStatement, FunctionDeclaration | TemplateDeclaration> }

circuitStatement {
    Pragma { kw<"pragma"> kw<"circom"> CompilerVersion }
  | Include { kw<"include"> String }
  | MainComponentDeclaration
}

MainComponentDeclaration { kw<"component"> kw<"main"> PublicSignalsList? "=" Call }
PublicSignalsList { OpenBrace kw<"public"> OpenBracket list<Identifier> CloseBracket CloseBrace }

controlFlowBlock<statement> {
    If<statement>
  | ForLoop<statement>
  | WhileLoop<statement>
}

controlFlowBody<name, statement> {
    OpenBrace controlFlowBodyBlock[@name={name}] { body<statement, controlFlowBlock<statement>> } CloseBrace
  | controlFlowBodyStatement[@name={name}] { statement } ";"
}

If<statement> {
  kw<"if"> OpenParen IfCondition { booleanExpression } CloseParen controlFlowBody<"IfBody", statement> (kw<"else"> controlFlowBody<"ElseBody", statement>)?
}

ForLoop<statement> {
  kw<"for"> OpenParen ForLoopInitialization { statement } ";" ForLoopCondition { booleanExpression } ";" ForLoopStepCode { statement } CloseParen controlFlowBody<"ForLoopBody", statement>
}

WhileLoop<statement> {
  kw<"while"> OpenParen WhileLoopCondition { booleanExpression } CloseParen controlFlowBody<"WhileLoopBody", statement>
}

FunctionDeclaration { kw<"function"> Identifier ParameterList OpenBrace FunctionBody CloseBrace }
FunctionBody { body<functionStatement, controlFlowBlock<functionStatement>> }

functionStatement {
    VariableDeclaration
  | Assignment
  | arithmeticAssignment
  | bitwiseAssignment
  | Assert
  | Log
  | Return { kw<"return"> numericExpression }
}

TemplateDeclaration { kw<"template"> kw<"parallel">? Identifier ParameterList OpenBrace TemplateBody CloseBrace }
TemplateBody { body<topLevelTemplateStatement, controlFlowBlock<templateStatement>> }

topLevelTemplateStatement {
    SignalDeclaration { kw<"signal"> (kw<"input"> | kw<"output">)? Identifier ArraySize* ~reference }
  | ComponentDeclaration { kw<"component"> Identifier (ArraySize+ | "=" Call)? }
  | templateStatement
}

templateStatement {
    VariableDeclaration
  | Assignment
  | arithmeticAssignment
  | bitwiseAssignment
  | AssignSignalRight { topLevelNumericExpression "-->" Value }
  | AssignSignalLeft { Value "<--" topLevelNumericExpression }
  | AssignConstraintSignalRight { topLevelNumericExpression "==>" Value }
  | AssignConstraintSignalLeft { Value "<==" topLevelNumericExpression }
  | ConstrainSignal { topLevelNumericExpression "===" topLevelNumericExpression }
  | Assert
  | Log
}

VariableDeclaration { kw<"var"> Identifier ArraySize* ("=" nestedArray<topLevelNumericExpression>)? }
Assignment { Identifier ArrayIndex* "=" nestedArray<topLevelNumericExpression> }

booleanExpression[@isGroup="BooleanExpression"] {
    BooleanExpressionGroup { OpenParen booleanExpression CloseParen }
  | BooleanAnd { booleanExpression !L8 "&&" booleanExpression }
  | BooleanOr { booleanExpression !L9 "||" booleanExpression }
  | BooleanNegation { "!" booleanExpression }
  | LT { numericExpression "<" numericExpression }
  | LTE { numericExpression "<=" numericExpression }
  | GT { numericExpression ">" numericExpression }
  | GTE { numericExpression ">=" numericExpression }
  | EQ { numericExpression "==" numericExpression }
  | NEQ { numericExpression "!=" numericExpression }
}

topLevelNumericExpression[@isGroup="NumericExpression"] { Conditional | numericExpression }

Conditional {
  Condition { booleanExpression } "?" TrueValue { numericExpression } ":" FalseValue { numericExpression } 
}

numericExpression {
    NumericExpressionGroup { OpenParen numericExpression CloseParen }
  | arithmeticOperation
  | bitwiseOperation
  | Call
  | Value
  | Number
}

// Value could either be a variable or a signal,
// there's no way to syntactically distinguish them.
Value { Identifier Signal { "." Identifier }? ArrayIndex* ~reference }

// Call could either be a template or function call - since components can be initialized
// and then assigned separately, there's no way to syntactically distinguish them.
Call { Identifier ParameterValueList }

arithmeticOperation {
    Addition { numericExpression !L3 "+" numericExpression }
  | Subtraction { numericExpression !L3 "-" numericExpression }
  | Multiplication { numericExpression !L2 "*" numericExpression }
  | Exponentiation { numericExpression !L1 "**" numericExpression }
  | Division { numericExpression !L2 divide numericExpression }
  | Quotient { numericExpression !L2 "\\" numericExpression }
  | Remainder { numericExpression !L2 "\%" numericExpression }
}

arithmeticAssignment {
    AdditionAssignment { Identifier "+=" topLevelNumericExpression }
  | SubtractionAssignment { Identifier "-=" topLevelNumericExpression }
  | MultiplicationAssignment { Identifier "*=" topLevelNumericExpression }
  | ExponentiationAssignment { Identifier "**=" topLevelNumericExpression }
  | DivisionAssignment { Identifier divideAssign topLevelNumericExpression }
  | QuotientAssignment { Identifier "\\=" topLevelNumericExpression }
  | RemainderAssignment { Identifier "\%=" topLevelNumericExpression }
  | Increment { Identifier "++" }
  | Decrement { Identifier "--" }
}

bitwiseOperation {
    BitwiseAnd { numericExpression !L5 "&" numericExpression }
  | BitwiseOr { numericExpression !L7 "|" numericExpression }
  | BitwiseComplement { "~" numericExpression }
  | ExclusiveOr { numericExpression !L6 "^" numericExpression }
  | RightShift { numericExpression !L4 ">>" numericExpression }
  | LeftShift { numericExpression !L4 "<<" numericExpression }
}

bitwiseAssignment {
    BitwiseAndAssignment { Identifier "&=" topLevelNumericExpression }
  | BitwiseOrAssignment { Identifier "|=" topLevelNumericExpression }
  | BitwiseComplementAssignment { "~=" Identifier }
  | ExclusiveOrAssignment { Identifier "^=" topLevelNumericExpression }
  | RightShiftAssignment { Identifier ">>=" topLevelNumericExpression }
  | LeftShiftAssignment { Identifier "<<=" topLevelNumericExpression }
}